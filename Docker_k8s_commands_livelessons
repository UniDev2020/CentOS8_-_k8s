Docker, k8s
#                                  Docker
docker ps                                    show all your containers
# Installing Docker
# Remove any versions of docker:
sudo yum remove docker \
                  docker-client \
                  docker-client-latest \
                  docker-common \
                  docker-latest \
                  docker-latest-logrotate \
                  docker-logrotate \
                  docker-engine
# Install required packages
sudo yum install -y yum-utils \
  device-mapper-persistent-data \
  lvm2
# Use the following command to set up the stable repository.
sudo yum-config-manager \
    --add-repo \
    https://download.docker.com/linux/centos/docker-ce.repo
# Install the latest version of Docker Engine - Community and containerd
sudo yum install docker-ce docker-ce-cli containerd.io
sudo systemctl enable docker
sudo systemctl start docker
systemctl status docker
########################################################################
docker info                                   verify that it is running
docker info | less                            very useful to show how much disk space has used
docker search fedora                          search for containers on Docker Hub
docker run fedora echo Hello world            start the container with command
docker ps                                     show running containers
docker ps -all                                verify operations
docker image list                             verify images
docker container ls                           verify containers
docker run -it fedora /bin/bash               start a shell on a container
# Ctrl + 'p' then Ctrl + 'q'                  detach from a running container
usermod -aG docker user                       run Docker commands as non-root user

docker pull <image>                           pull images from Docker Hub
docker run  <image>                           if it isn't locally, pull and run it
docker run --help | less                      run command has many options
docker push  <image>                          push images on Docker Hub
docker images                                 available docker images
docker rmi <image>                            remove images
docker save <image>
docker load <image>
docker attach <container>                     brings to the container environment
docker version                                compare client and server versions of Docker
docker top <container>                        provides info about processes inside Docker
docker stats <container>                      provides realtime info about activity of container
docker cp <container>:path path               copy files from container
docker exec <container> <command>             run a command inside the container
docker kill <container>
docker stop <container>                       stop a container
docker start <container>                      start a container
docker pause <container>                      suspend a container
docker unpause <container>                    unsuspend a container
docker rm <container>                         remove these containers
docker rm $( docker ps -aq)                   delete all containers
docker inspect <container>                    all the properties of a container
#########################################################################
# pull the latest image, -dit demonize a container and open in interactive
# give a name to the container, run and starting a command
docker run -dit --name centos --hostname=centos centos /bin/bash
docker attach centos
exit                                          when exit from the command in container, container stops
# filter an information about a container and show necessary parameter
docker inspect -f '{{ .NetworkSettings.IPAddress }}' <container>     show  ip address
#                               Network and containers
docker run -d --name httpd -p 8080:80 httpd                          port mapping to make them accessible
curl http://localhost:8080                                           check a connection
#
docker run -d name httpd2 -p 192.168.1.150:8090:80 httpd             IP address for the port forward
#                                     Storage
# On RHEL a host directory should have the svirt_sandbox_file_t context label for SELinux
# on the host directory use chown to set the appropriate UID and GID as owner
# for example for mariadb to have a persistent database:
mkdir -p /var/local/mysql
setenforce 0
chown -R 27:27 /var/local/mysql
docker pull mariadb
docker run --name mariadb -d -v /var/local/mysql:/var/lib/mysql \
                   -e MYSQL_USER=user -e MYSQL_PASSWORD=password \
                   -e MYSQL_DATABASE=addresses -e MYSQL_ROOT_PASSWORD=password mariadb
docker ps
ls -l /var/local/mysql/
docker -exec -it mariadb /bin/bash
ls -l /var/lib/mysql/


#                                  K8s
# ~/.kube/config    file to find info of what to connect to
# cluster: the k8s cluster, user: the autorized user
# the part of the cluster the user wants to access, typically a namespace
vim ~/.kube/config                            specify how to connect to different clusters in one config file
kubectl config view                           show current configuration
kubectl cluster-info
kubectl get                                   show resources are available
            all
            podes
            nodes
            deployments
# Connecting to a Remote Cluster
kubectl config set-cluster mycluster --server=http://ip:port --api-version=v1    to connect to the cluster
kubectl use-context mycluster                 start using it
# configure access multiple clusters for more information see the website

kubectl run                                   create a deployment or job to manage the created containers
kubectl run ngnix --image=nginx               create a deployment
kubectl run fedora --image=fedora             create a deployment
kubectl delete deployment fedora              delete a deployment
kubectl run fedora --image=fedora -- /usr/bin/sleep 3600         create a deployment with a command in it

#                               Minikube
minikube start                                start the environment
minikube status                               status of services
minikube ssh                                  minikube prompt
                 top                          different parameters
                 docker ps                    show containers
                 ps aux                       show processes
                 ps aux | localku             show a core process in minikub env
                 free -m                      memory
                 df -h                        disk spaces
minikube ip                                   show minikube ip address
minikube dashboard                            start WEB UI
minikube logs                                 give you the log information

#                                Pods with YAML files
# Specification of how to run these containers
kubectl create -f <name>.yaml                     create a pod, if some problems use --validate=false
# alternatively, use the Dashboard
kubectl get pods                                  show all running pods
kubectl get pods -o wide                               more information
kubectl describe pods <podname>                   show all details about pods
kubectl delete pod <podname>                      delete a pod

#                                 Namespaces
# Strict isolation between resources, it allows to create separated areas
# It guarantees the secure environments that occurs on Linux Kernel level
# By default k8s has three namespaces: default, kube-public, kube-system
kubectl get ns                                    show namespaces
kubectl create ns secret                          create a namespace
kubectl get ns secret -o yaml                     get in yaml format for more details
kubectl get ns secret -o json                     the same in a json format

#                                   Replica Sets
# If you create a replica set by deployment, it's shouldn't scale anymore.
# kubectl scale --current-replicas=1 --replicas=3 deployment <podname>
kubectl run nginx --image-nginx                   create with image from repository
kubectl get rs                                    show replica set
kubectl get rs <rsname> -o yaml                   show more info about the replica set
kubectl scale --replicas=3 deployment nginx       scaled a replica set from deployment
                                                  can scale and unscale your replicas
kubectl delete rs <rsname>                        stop an active replica set, and deployment
                                                  start it again
#                                   Deployments
# Used to create and automate replica sets
# Instruct the cluster how to create and scale applications
# Monitor instances of an application
kubectl get all
kubectl get deployments                           show the deployments
kubectl delete deployment <depname>               delete the deployment
kubectl describe deployment <depname>             information about dep

#                                 Troubleshooting
kubectl get deployments
kubectl describe deployment <depname>
kubectl describe pods <podname>
kubectl logs <podname>
